{"remainingRequest":"C:\\Users\\dscjh\\Desktop\\note\\vue\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\dscjh\\Desktop\\note\\vue\\node_modules\\eslint-loader\\index.js??ref--13-0!C:\\Users\\dscjh\\Desktop\\note\\vue\\src\\libs\\crypto_rsa_long.js","dependencies":[{"path":"C:\\Users\\dscjh\\Desktop\\note\\vue\\src\\libs\\crypto_rsa_long.js","mtime":1578481752848},{"path":"C:\\Users\\dscjh\\Desktop\\note\\vue\\.babelrc","mtime":1569934280000},{"path":"C:\\Users\\dscjh\\Desktop\\note\\vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\dscjh\\Desktop\\note\\vue\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\dscjh\\Desktop\\note\\vue\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.typed.uint16-array\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport \"core-js/modules/es6.regexp.split\";\nimport { JSEncrypt } from 'jsencrypt'; // Convert a hex string to a byte array  16进制转byte数组\n\nimport pako from 'pako';\n\nfunction unzip(b64Data) {\n  var strData = atob(b64Data); // Convert binary string to character-number array\n\n  var charData = strData.split('').map(function (x) {\n    return x.charCodeAt(0);\n  }); // Turn number array into byte-array\n\n  var binData = new Uint8Array(charData); // // unzip\n\n  var data = pako.inflate(binData); // Convert gunzipped byteArray back to ascii string:\n\n  strData = String.fromCharCode.apply(null, new Uint16Array(data));\n  return decodeURIComponent(strData);\n}\n\nfunction zip(str) {\n  var binaryString = pako.gzip(encodeURIComponent(str), {\n    to: 'string'\n  });\n  return btoa(binaryString);\n}\n\nfunction hexToBytes(hex) {\n  for (var bytes = [], c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.substr(c, 2), 16));\n  }\n\n  return bytes;\n}\n\nJSEncrypt.prototype.encryptLong2 = function (string) {\n  var k = this.getKey();\n\n  try {\n    var ct = \"\"; //RSA每次加密最大117bytes，需要辅助方法判断字符串截取位置\n    //1.获取字符串截取点\n\n    var bytes = new Array();\n    bytes.push(0);\n    var byteNo = 0;\n    var len, c;\n    len = string.length;\n    var temp = 0;\n\n    for (var i = 0; i < len; i++) {\n      c = string.charCodeAt(i);\n\n      if (c >= 0x010000 && c <= 0x10FFFF) {\n        byteNo += 4;\n      } else if (c >= 0x000800 && c <= 0x00FFFF) {\n        byteNo += 3;\n      } else if (c >= 0x000080 && c <= 0x0007FF) {\n        byteNo += 2;\n      } else {\n        byteNo += 1;\n      }\n\n      if (byteNo % 117 >= 114 || byteNo % 117 == 0) {\n        if (byteNo - temp >= 114) {\n          bytes.push(i);\n          temp = byteNo;\n        }\n      }\n    } //2.截取字符串并分段加密\n\n\n    if (bytes.length > 1) {\n      for (var i = 0; i < bytes.length - 1; i++) {\n        var str;\n\n        if (i == 0) {\n          str = string.substring(0, bytes[i + 1] + 1);\n        } else {\n          str = string.substring(bytes[i] + 1, bytes[i + 1] + 1);\n        }\n\n        var t1 = k.encrypt(str);\n        ct += t1;\n      }\n\n      ;\n\n      if (bytes[bytes.length - 1] != string.length - 1) {\n        var lastStr = string.substring(bytes[bytes.length - 1] + 1);\n        ct += k.encrypt(lastStr);\n      }\n\n      return hexToBytes(ct);\n    }\n\n    var t = k.encrypt(string);\n    var y = hexToBytes(t);\n    return y;\n  } catch (ex) {\n    return false;\n  }\n};\n\nfunction arrayBufferToBase64(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var len = bytes.byteLength;\n\n  for (var i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n\n  return window.btoa(binary);\n}\n\nexport function Encrypt(data) {\n  var encrypt = new JSEncrypt();\n  encrypt.setPublicKey('-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDbqZCwjBRSKd64fM/ortRglY/VIP+qdqB2rk3EKmWQnhwMREqSoUwVnyPQqj61mVguox1rh4LSgyRvAzYJc9FUKvDkcKsUm07qgzUhbS/B6XpdGqLlh+ror/J2CJuwn3KQDfgMg5gb4Bi98yo0CAfOYo3QqrPmXthBbEHuCyvasQIDAQAB-----END PUBLIC KEY-----'); // 公钥\n\n  var getrsadata = arrayBufferToBase64(encrypt.encryptLong2(zipdata)); //将加密的数据转码为base64\n\n  return getrsadata; //加密后的数据\n}\nexport default {\n  Encrypt: Encrypt\n};",{"version":3,"sources":["C:\\Users\\dscjh\\Desktop\\note\\vue\\src\\libs\\crypto_rsa_long.js"],"names":["JSEncrypt","pako","unzip","b64Data","strData","atob","charData","split","map","x","charCodeAt","binData","Uint8Array","data","inflate","String","fromCharCode","apply","Uint16Array","decodeURIComponent","zip","str","binaryString","gzip","encodeURIComponent","to","btoa","hexToBytes","hex","bytes","c","length","push","parseInt","substr","prototype","encryptLong2","string","k","getKey","ct","Array","byteNo","len","temp","i","substring","t1","encrypt","lastStr","t","y","ex","arrayBufferToBase64","buffer","binary","byteLength","window","Encrypt","setPublicKey","getrsadata","zipdata"],"mappings":"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","sourcesContent":["import { JSEncrypt } from 'jsencrypt'\r\n// Convert a hex string to a byte array  16进制转byte数组\r\n\r\nimport pako from 'pako'\r\n\r\nfunction unzip(b64Data){\r\n    var strData   = atob(b64Data);\r\n    // Convert binary string to character-number array\r\n    var charData  = strData.split('').map(function(x){return x.charCodeAt(0);});\r\n    // Turn number array into byte-array\r\n    var binData   = new Uint8Array(charData);\r\n    // // unzip\r\n    var data    = pako.inflate(binData);\r\n    // Convert gunzipped byteArray back to ascii string:\r\n    strData   = String.fromCharCode.apply(null, new Uint16Array(data));\r\n    return decodeURIComponent(strData);\r\n}\r\nfunction zip(str){\r\n     var binaryString = pako.gzip(encodeURIComponent(str), { to: 'string' })\r\n     return btoa(binaryString);\r\n}\r\n\r\nfunction hexToBytes(hex) {\r\n  for (var bytes = [], c = 0; c < hex.length; c += 2)\r\n    bytes.push(parseInt(hex.substr(c, 2), 16));\r\n  return bytes;\r\n}\r\n\r\nJSEncrypt.prototype.encryptLong2 = function (string) {\r\n  var k = this.getKey(); \r\n  try {\r\n    var ct = \"\";     //RSA每次加密最大117bytes，需要辅助方法判断字符串截取位置\r\n    //1.获取字符串截取点\r\n    var bytes = new Array();\r\n    bytes.push(0);\r\n    var byteNo = 0;\r\n    var len, c;\r\n    len = string.length;\r\n    var temp = 0;\r\n    for (var i = 0; i < len; i++) {\r\n      c = string.charCodeAt(i);\r\n      if (c >= 0x010000 && c <= 0x10FFFF) {\r\n        byteNo += 4;\r\n      } else if (c >= 0x000800 && c <= 0x00FFFF) {\r\n        byteNo += 3;\r\n      } else if (c >= 0x000080 && c <= 0x0007FF) {\r\n        byteNo += 2;\r\n      } else {\r\n        byteNo += 1;\r\n      }\r\n      if ((byteNo % 117) >= 114 || (byteNo % 117) == 0) {\r\n        if (byteNo - temp >= 114) {\r\n          bytes.push(i);\r\n          temp = byteNo;\r\n        }\r\n      }\r\n    }\r\n    //2.截取字符串并分段加密\r\n    if (bytes.length > 1) {\r\n      for (var i = 0; i < bytes.length - 1; i++) {\r\n        var str;\r\n        if (i == 0) {\r\n          str = string.substring(0, bytes[i + 1] + 1);\r\n        } else {\r\n          str = string.substring(bytes[i] + 1, bytes[i + 1] + 1);\r\n        }\r\n        var t1 = k.encrypt(str);\r\n        ct += t1;\r\n      };\r\n      if (bytes[bytes.length - 1] != string.length - 1) {\r\n        var lastStr = string.substring(bytes[bytes.length - 1] + 1);\r\n        ct += k.encrypt(lastStr);\r\n      }\r\n      return hexToBytes(ct);\r\n    }\r\n    var t = k.encrypt(string);\r\n    var y = hexToBytes(t);\r\n    return y;\r\n  } catch (ex) {\r\n    return false;\r\n  }\r\n};\r\n\r\nfunction arrayBufferToBase64(buffer) {\r\n  var binary = '';\r\n  var bytes = new Uint8Array(buffer);\r\n  var len = bytes.byteLength;\r\n  for (var i = 0; i < len; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n  return window.btoa(binary);\r\n}\r\n\r\nexport function Encrypt(data) {\r\n    let encrypt = new JSEncrypt()\r\n    encrypt.setPublicKey('-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDbqZCwjBRSKd64fM/ortRglY/VIP+qdqB2rk3EKmWQnhwMREqSoUwVnyPQqj61mVguox1rh4LSgyRvAzYJc9FUKvDkcKsUm07qgzUhbS/B6XpdGqLlh+ror/J2CJuwn3KQDfgMg5gb4Bi98yo0CAfOYo3QqrPmXthBbEHuCyvasQIDAQAB-----END PUBLIC KEY-----') // 公钥\r\n    let getrsadata = arrayBufferToBase64(encrypt.encryptLong2(zipdata)); //将加密的数据转码为base64\r\n    return getrsadata //加密后的数据\r\n}\r\n\r\nexport default {\r\n    Encrypt\r\n}\r\n\r\n"]}]}